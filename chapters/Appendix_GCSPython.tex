\chapter{Implementation of the Graduated Cylindrical Shell model in Python}
\label{chp:GCS_Python}

The \acl{GCS}\acused{GCS} model \citep[\acs{GCS},][]{Thernisien-2006-GCS,Thernisien-2011-GCS} is an empirical model that is commonly used to represent the three-dimensional structure of flux rope \acp{CME}  near the Sun. It defines a croissant-like 3D shape with conical legs whose ends are anchored to the center of the Sun, as shown in \autoref{fig:gcs_schematic}.

\begin{figure}
    \input{images/gcs_schematic.tex}
    \caption[Illustration of the \acs{GCS} model]{Illustration of the \ac{GCS} model and definition of parameters $h, h_\text{apex}$, $\alpha$, $\delta$ and $R_\text{apex}$, based on \citet{Thernisien-2011-GCS}. In this example, the parameters are set to $\alpha = \SI{30}{\degree}$ and $\kappa = 0.35$. The left panel shows a side view of the \ac{CME} in the $xy$ plane, where the thick black line marks the outer contour of the flux rope and the red line corresponds to its central axis. The dotted lines mark the boundary between the front section and the legs. The dashed line is a circular arc around the central point, showing that the front section does not have a constant radius. The right panel shows a cut in the perpendicular $yz$ plane, where the cross section of the front is marked with a thick circle and the conical legs are indicated using the thin lines.}
    \label{fig:gcs_schematic}
\end{figure}

The \ac{GCS} geometry is constrained using three main parameters: The \ac{CME} apex height $h_\text{apex}$ (or, alternatively, the leg height $h$), the angular half width $\alpha$ of the \ac{CME}, and the so-called aspect ratio $\kappa$, which corresponds to the half angle $\delta$ of the leg cones:
\begin{equation}
    \kappa = \sin \delta
\end{equation}
The origin of the coordinate system shown in \autoref{fig:gcs_schematic} is fixed to the center of the Sun, with the $y$ axis defining the propagation direction of the CME. Three additional parameters describe its orientation: The heliographic latitude $\theta$ and longitude $\phi$ (typically given in Stonyhurst or Carrington coordinates), and the tilt angle $\gamma$, which defines the rotation around the $y$ axis in \autoref{fig:gcs_schematic}. For a detailed description of the mathematical derivation of the \ac{GCS} model, please refer to \citet{Thernisien-2011-GCS}.

The \ac{GCS} model is typically employed in a forward modelling approach, i.e., the model is visually compared to coronagraph observations of a \ac{CME} and the input parameters are then iteratively adjusted by the scientist to achieve a good fit. This manual fitting process is ideally applied simultaneously to coronagraph images from multiple viewpoints, such as from the \ac{SOHO}/\ac{LASCO} and \ac{STEREO}/\ac{SECCHI} coronagraphs, to avoid ambiguity due to the line of sight effect. The resulting \ac{GCS} parameters for the best fit can then be used for further evaluation, e.g. as input parameters for modeling the subsequent CME propagation. Additional properties of the flux rope, such as the radius at the apex $R_\text{apex}$ (see \autoref{fig:gcs_schematic}) can also be calculated from these parameters, as derived by \citep{Thernisien-2011-GCS}. When applied to a sequence of consecutive images, the \ac{CME} kinematics can also be reconstructed.

The original implementation of the \ac{GCS} model in the \ac{IDL}\footnote{\url{https://www.l3harrisgeospatial.com/Software-Technology/IDL}} and a corresponding \ac{GUI} were developed by \citet{Thernisien-2006-GCS} and are included in the SolarSoft software package \citep{Freeland-1998-SolarSoft} under the name \texttt{scraytrace}\footnote{\url{https://hesperia.gsfc.nasa.gov/ssw/stereo/secchi/idl/scraytrace}}.
SolarSoft is a collection of \ac{IDL} software libraries that was originally developed in the 1990s by members of the Yohkoh and \ac{SOHO} mission teams and the NASA Solar Data Analysis Center (SDAC), and some tools from other missions such as \ac{STEREO} were also included later.
Using this \ac{GCS} implementation requires a license of \ac{IDL}, a local installation of SolarSoft and the corresponding database (SSWDB), which includes coronagraph images and calibration data. Obtaining and installing all these components is quite involved for scientists that are not familiar with \ac{IDL} and SolarSoft. Additionally, the \ac{GCS} implementation is only partially documented and not very flexible, as it was initially hard-coded to work with only \ac{STEREO}-A and -B data, with support for \ac{SOHO} being manually added later.

As described e.g. in the detailed review by \citet{Burrell-2018}, the Python programming language is becoming increasingly popular in the solar and heliospheric physics community, and consequently, various open source software libraries to assist with the associated data analysis are available. Python is a modern, general-purpose object-oriented programming language that is easy to learn and emphasizes code readability. According to the TIOBE Programming Community Index\footnote{\url{https://www.tiobe.com/tiobe-index/}}, it has recently surpassed Java as the second most popular programming language in the world, and in contrast to \ac{IDL}, it is open source software (OSS) and available free of charge on all major operating systems.

\textit{SunPy} \citep{sunpy_community2020}, a library for working with solar images from various missions, is one of the most widely-used Python toolkits for solar physics. However, it does not yet provide any models for \ac{CME} reconstruction in coronagraph images.
Thus, an open source Python implementation of the \ac{GCS} model and a simple corresponding \ac{GUI} application based on \textit{SunPy} have been developed during the course of the study presented in \citet{Forstner-2021-SolO}. It can be used both as as a standalone application as well as integrated into existing Python-based plotting routines. The source code is available on GitHub at \url{https://github.com/johan12345/gcs_python}, and is also mirrored at Kiel University under \url{https://gitlab.physik.uni-kiel.de/ET/gcs_python}. It can be easily installed with Python's \texttt{pip} package manager as follows:
\begin{minted}{bash}
pip3 install git+https://github.com/johan12345/gcs_python.git
\end{minted}
(provided that Python 3.7 or above is already installed).

The following sections will describe the design and usage of this software package, and its validation against the original \ac{IDL} version.

\section{GCS geometry}

The basic \ac{GCS} geometry is implemented in the \texttt{gcs.geometry} module. This code is a close translation of the corresponding \ac{IDL} routines from SolarSoft. Two basic functions are provided to calculate the geometry of the \ac{GCS} structure based on the input parameters: The \texttt{skeleton} function (based on \texttt{shellskeleton.pro} in SolarSoft) calculates the shape of the central axis of the flux rope (thin solid line in \autoref{fig:gcs_schematic}), which consists of two straight segments in the legs and a curved segment in the front. The desired resolution, i.e. the number of points along each part of the curve, can be passed to the function.
This central axis, which lies in the $xy$ plane, then needs to be used to generate the outer shell of the flux rope, which consists of circles that are perpendicular to the tangent vector at each point. For this purpose, the \texttt{skeleton} function also provides the orientation of this tangent vector as well as the radius of each circle.
The \verb|gcs_mesh| function (based on \texttt{cmecloud.pro} in SolarSoft) then uses the output of the \texttt{skeleton} function to construct a 3D mesh by generating these circles around the central axis with the appropriate radius and orientation. The parameters of the \verb|gcs_mesh| function are the half angle $\alpha$, the \ac{CME} height $h_\text{apex}$, and the aspect ratio $\kappa$, as well as the desired numbers of points along the straight segments, along the front, and along each circle in the mesh.

\begin{figure}
	\centering
	\input{plots/gcs_geometry.pgf}
	\caption[Results of the functions from \acs{GCS}-Python]{Results of the functions from the \ac{GCS} Python implementation. The left panel shows the central axis of the flux rope, calculated using the \texttt{skeleton} function, in orange, and the surrounding circles generated by the \texttt{gcs\_mesh} function in blue. The right panel shows a 3D wireframe representation of the same data. The input parameters $\alpha$ and $\kappa$ are the same as in \autoref{fig:gcs_schematic}.}
	\label{fig:gcs_geometry}
\end{figure}

In addition to these basic routines to construct the \ac{GCS} mesh, there is also a function \verb|gcs_mesh_rotated|, which uses the three angles $\theta, \phi, \gamma$ to rotate the \ac{CME} cloud in 3D space, as well as the function \verb|gcs_mesh_sunpy|, which converts the rotated \ac{GCS} mesh into a \textit{SunPy} \texttt{SkyCoord} object. This object then contains the necessary metadata about the coordinate system so that the model can directly be integrated into a \textit{SunPy} plot.

\section{Graphical user interface}

In addition to the implementation of the \ac{GCS} geometry, a convenient \ac{GUI} was created that can be used to fit the \ac{GCS} model to coronagraph images. The \ac{GUI} is based upon \textit{SunPy}, which already provides functions to obtain coronagraph images and to perform the coordinate transformations necessary to overplot arbitrary points in space on these images. Thus, its implementation was relatively straightforward.

For starting the \ac{GUI}, a command line interface is provided. For example,
\begin{minted}{bash}
gcs_gui "2013-05-13 16:54" STB SOHO STA
\end{minted}
starts the \ac{GCS} \ac{GUI} with the closest available coronagraph images to the given date and time from \ac{STEREO}-B, \ac{SOHO} and \ac{STEREO}-A. Additional command line options are available to set which coronagraph should be used (\texttt{-soho C2} or \texttt{C3}, and \texttt{-stereo COR1} or \texttt{COR2}) and whether to use running difference images (\texttt{-rd}) or direct images. Running difference images are calculated by subtracting a previous image (e.g. \SI{1}{\hour} before) from the current one, so that moving features are highlighted.

The \ac{GUI} components, e.g. sliders and text boxes for each input parameter, were implemented using the \textit{PyQt5} library \footnote{\url{https://riverbankcomputing.com/software/pyqt/}}, which provides Python bindings for the popular \ac{GUI} framework \textit{Qt}. The \ac{GUI} is defined in the \texttt{gcs.gui} module as the \texttt{GCSGui} class. For embedding the solar images into the Qt window, it uses a plotting canvas provided by the \textit{matplotlib} plotting package (\texttt{FigureCanvasQTAgg}).

When the user starts the \ac{GUI}, it first retrieves the desired coronagraph images through the Internet. This is done using the Helioviewer.org Application Programming Interface (API) \footnote{\url{https://api.helioviewer.org/docs/v2/}}, which directly provides images in JPEG2000 format to which all necessary calibration and background subtraction routines were already applied on the server side. This drastically simplifies and speeds up the process compared to the \ac{IDL} version, where images in FITS format need to be downloaded manually from the respective mission sites, and where the calibration procedure needs to be applied locally (requiring an installation of SSWDB). The JPEG2000 images provided by Helioviewer.org also include additional metadata about the observer location and field of view, which are copied from the original FITS file and are necessary to plot the images in the correct coordinate system (solar latitude and longitude).

When the images are downloaded, the \ac{GCS} \ac{GUI} plots them using \textit{SunPy} and displays the result in the plotting canvas (see \autoref{fig:gcs_screenshot}). The \ac{GCS} croissant mesh is then plotted on top of these images and the user can adjust the \ac{GCS} parameters interactively with the six sliders and numerical input boxes on the right side of the window. Three additional controls are provided: A checkbox to show or hide the \ac{GCS} mesh, a text view showing the calculated apex radius of the flux rope ($R_\text{apex}$, cf. \autoref{fig:gcs_schematic}), and a button to save the \ac{GCS} parameters to a file. These data are stored in the \ac{JSON} format, a general-purpose data format that is human-readable and can be easily handled with most modern programming languages. On the upper edge of the \ac{GCS} window, the standard \textit{matplotlib} controls are also shown to allow zooming and panning in the images as well as saving the current set of images to a file.

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{images/gcs_screenshot.png}
	\caption[Screenshot of the \acs{GCS} Python \acs{GUI}]{Screenshot of the \ac{GCS} Python \ac{GUI}. The left part of the window shows the plotting canvas with running difference coronagraph images of the April 15, 2020 \ac{CME} \citep[see][]{Forstner-2021-SolO}. The user controls for the \ac{GCS} parameters are shown on the right.}
	\label{fig:gcs_screenshot}
\end{figure}

During the development of the \ac{GCS} \ac{GUI}, two problems with the data provided to \textit{SunPy} by the Helioviewer.org \ac{API} were discovered: First, the \ac{STEREO}-B COR2 images were temporarily not available through the \ac{API} in October 2020, an issue which has since been resolved by the Helioviewer.org team\footnote{\url{https://github.com/Helioviewer-Project/helioviewer.org/issues/288}}. Second, there was an issue with the metadata included in the \ac{SOHO}/LASCO files: The \ac{SOHO} spacecraft performs a roll maneuver every three months to keep its high gain antenna oriented towards Earth. The files provided by Helioviewer.org already take this into account by rotating the images accordingly, so that the solar north pole is always pointing upwards. However, the metadata in the JPEG2000 files are not adjusted accordingly\footnote{\url{https://github.com/sunpy/sunpy/issues/4553}}, so \textit{SunPy} still interprets these images as though they were rotated by \SI{180}{\degree}. This obviously caused the location of the \ac{GCS} model results in the LASCO images to be incorrect. Thus, a workaround was implemented into the \ac{GCS} \ac{GUI} to reset the rotation metadata of the LASCO files and also submitted a patch\footnote{\url{https://github.com/sunpy/sunpy/pull/4561}} to the \textit{SunPy} project to address this issue, which is included in version 2.1 of \textit{SunPy}.

Possible future improvements to the \ac{GCS} \ac{GUI} could include adding an option to calculate base difference images as an alternative to the current options of direct and running difference images, i.e. allowing the user to specify a fixed point in time that should be used for the subtraction. It may also be helpful to include additional controls for the user to adjust the contrast of the displayed images --- this is already possible in the \ac{IDL} implementation, but only before starting the fitting process, it cannot be changed interactively while already working on the fit. In addition, further tools could be provided to facilitate the fitting of time series so that the user can simply provide a start and end time, and the \ac{GUI} would directly provide one image after another and store the fitting results for each time step in one file. The toolkit may also be easily extended to include support for additional data sources as soon as they are implemented in \textit{SunPy}, such as the Wide-Field Imager onboard Parker Solar Probe \citep[WISPR,][]{Vourlidas-2016-WISPR}, the Metis coronagraph onboard Solar Orbiter \citep{Antonucci-2020-Metis} and the Solar Orbiter Heliospheric Imager \citep[SoloHI,][]{Howard-2020-SoloHI}.

\section{Validation}

To validate that the Python implementation of \ac{GCS} yields the correct results, a set of \acp{CME} were re-plotted  with the Python \ac{GCS} \ac{GUI} that have previously been fitted using the \ac{IDL} version to compare the resulting plots. One example of this is shown in \autoref{fig:gcs_validation} for a \ac{CME} launched on May 13, 2013 \citep[originally reconstructed by][Figure 2]{Gou-2020}. The corresponding input parameters are shown in \autoref{tab:gcs_validation_params}.

\begin{figure}
	\centering
	\includegraphics[width=0.9\textwidth]{images/gcs_validation_20130513_idl.png}\\[5mm]
	\includegraphics[width=\textwidth]{images/gcs_validation_20130513_python.pdf}
	\caption[Validation of the \acs{GCS} Python implementation]{Validation of the \ac{GCS} Python implementation. Both panels show the same \ac{CME} on May 13, 2013, with the \ac{GCS} parameters listed in \autoref{tab:gcs_validation_params}. The top image was generated by the \ac{IDL} implementation of \ac{GCS}, while the bottom panel shows the result of the new Python implementation.}
	\label{fig:gcs_validation}
\end{figure}

\begin{table}
	\centering
	\begin{tabular}{rS[table-format=3.2]}
		\toprule
		                                  {Parameter} & {Value} \\ \midrule
		   Stonyhurst Longitude $\phi$ [\si{\degree}] & 270     \\
		Heliographic Latitude $\theta$ [\si{\degree}] & 19      \\
		           Tilt angle $\gamma$ [\si{\degree}] & 35      \\
		           Half angle $\alpha$ [\si{\degree}] & 28      \\
		      Apex height $R_\text{apex}$ [$R_\odot$] & 10.8    \\
		                        Aspect ratio $\kappa$ & 0.35    \\ \bottomrule
	\end{tabular}
	\caption[\acs{GCS} parameters for \autoref{fig:gcs_validation}]{\ac{GCS} parameters for the May 13, 2013 \ac{CME} shown in \autoref{fig:gcs_validation}.}
	\label{tab:gcs_validation_params}
\end{table}

Similar comparisons were performed for other \acp{CME}  with different characteristics: The June 21, 2011 \ac{CME} \citep[originally reconstructed by][Table 1]{Heinemann-2019}, the May 25, 2014 \ac{CME} \citep[originally reconstructed by][Figure 5b]{Dumbovic2018-ForbMod}, as well as the April 15, 2020 \ac{CME} studied by \citet{Forstner-2021-SolO}. In all cases, the \ac{GCS} 3D meshes generated by the Python implementation match the \ac{CME} signatures in the coronagraph images as well as the original results from the \ac{IDL} implementation. This shows that the Python version is implemented correctly and can be used for scientific purposes.
