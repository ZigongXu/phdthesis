\chapter{Implementation of the Graduated Cylindrical Shell model in Python}
\label{chp:GCS_Python}

The \acl{GCS} model \citep[\acs{GCS},][]{Thernisien-2006-GCS,Thernisien-2011-GCS} is an empirical model that is commonly used to represent the three-dimensional structure of flux rope \acp{CME}  near the Sun. It defines a croissant-like 3D shape with conical legs whose ends are anchored to the center of the Sun, as shown in \autoref{fig:gcs_schematic}.

\begin{figure}
    \input{images/gcs_schematic.tex}
    \caption[Illustration of the \ac{GCS} model]{Illustration of the \ac{GCS} model and definition of parameters $h, h_\text{apex}$, $\alpha$, $\delta$ and $R_\text{apex}$. Adapted from \citet{Thernisien-2011-GCS}. In this example, the parameters are set to $\alpha = \SI{30}{\degree}$ and $\kappa = 0.35$. The left panel shows a side view of the \ac{CME} in the $xy$ plane, where the thick line marks the outer contour of the flux rope and the thin line corresponds to its central axis. The dotted lines mark the boundary between the front section and the legs. The dashed line is a circular arc around the central point, showing that the front section does not have a constant radius. The right panel shows a cut in the perpendicular $yz$ plane, where the cross section of the front is marked with a thick circle and the conical legs are indicated using the thin lines.}
    \label{fig:gcs_schematic}
\end{figure}

The \ac{GCS} geometry is constrained using 3 main parameters: The \ac{CME} apex height $h_\text{apex}$ (or, alternatively, the leg height $h$), the angular half width $\alpha$ of the \ac{CME}, and the so-called aspect ratio $\kappa$, which corresponds to the half angle $\delta$ of the leg cones:
\begin{equation}
    \kappa = \sin \delta
\end{equation}
Three additional parameters describe the orientation of the flux rope relative to the Sun: The heliographic latitude $\theta$, longitude $\phi$ (typically given in Stonyhurst or Carrington coordinates), and the tilt angle $\gamma$, which defines the rotation around the $y$ axis in \autoref{fig:gcs_schematic}. For a detailed description of the mathematical derivation of the \ac{GCS} model, please refer to \citet{Thernisien-2011-GCS}.

The \ac{GCS} model is typically employed in a forward modelling approach, i.e., the model is visually compared to coronagraph observations of a \ac{CME} and the input parameters are then iteratively adjusted by the scientist to achieve a good fit. This manual fitting process is ideally applied simultaneously to coronagraph images from multiple viewpoints, such as from the \ac{SOHO} and \ac{STEREO} spacecraft, to avoid ambiguity due to the line of sight effect. The resulting \ac{GCS} parameters for the best fit can then be used for further evaluation, e.g. as input parameters for further models. Additional properties of the flux rope, such as the radius at the apex $R_\text{apex}$ (see \autoref{fig:gcs_schematic}) can also be calculated from these parameters, as derived by \citep{Thernisien-2011-GCS}. When applied to a sequence of consecutive images, the \ac{CME} kinematics can also be reconstructed.

The original implementation of the \ac{GCS} model in the \ac{IDL}\footnote{\url{https://www.l3harrisgeospatial.com/Software-Technology/IDL}} and a corresponding \ac{GUI} were developed by \citet{Thernisien-2006-GCS} and is included in the SolarSoft software package \citep{Freeland-1998-SolarSoft} under the name \texttt{scraytrace}\footnote{\url{https://hesperia.gsfc.nasa.gov/ssw/stereo/secchi/idl/scraytrace}}.
Using this implementation requires a local installation of SolarSoft and the corresponding database (SSWDB), which includes coronagraph images and calibration data. Obtaining and installing all these components is quite involved for scientists that are not familiar \ac{IDL} and SolarSoft, and the \ac{GCS} implementation is only partially documented and not very flexible, as it was initially hard-coded to work with only \ac{STEREO}-A and -B data, with support for \ac{SOHO} being manually added later.

As described e.g. in the detailed review by \citet{Burrell-2018}, the Python programming language is becoming increasingly popular in the solar and heliospheric physics community, and consequently, various open source software libraries to assist with the associated data analysis are available. Python is a modern, general-purpose object-oriented programming language that is easy to learn and emphasizes code readability. According to the TIOBE Programming Community Index\footnote{\url{https://www.tiobe.com/tiobe-index/}}, it has recently surpassed Java as the second most popular programming language in the world, and in contrast to \ac{IDL}, it is open source software (OSS) and available free of charge on all major operating systems.

\textit{SunPy}, a library \citep{sunpy_community2020} for working with solar images from various missions, is one of the most widely-used Python toolkits for solar physics. However, it does not yet provide any models for \ac{CME} reconstruction in coronagraph images.
Thus, I have developed an open source Python implementation of the \ac{GCS} model and a simple corresponding \ac{GUI} application, based on \textit{SunPy}. It can be used both as as a standalone application as well as integrated into existing Python-based plotting routines. The source code is available on GitHub at \url{https://github.com/johan12345/gcs_python}, and is also mirrored at Kiel University under \url{https://gitlab.physik.uni-kiel.de/ET/gcs_python}. It can be easily installed with Python's \texttt{pip} package manager as follows:
\begin{minted}{bash}
pip3 install git+https://github.com/johan12345/gcs_python.git
\end{minted}
(provided that Python 3.7 or above is already installed).

The following sections will describe the design and usage of this software package, and its validation against the original \ac{IDL} version.

\section{GCS geometry}

The basic \ac{GCS} geometry is implemented in the \texttt{gcs.geometry} module. This code is a close translation of the corresponding \ac{IDL} routines from SolarSoft. Two basic functions are provided to calculate the geometry of the \ac{GCS} structure based on the input parameters: The \texttt{skeleton} function (based on \texttt{shellskeleton.pro} in SolarSoft) calculates the shape of the central axis of the flux rope (thin solid line in \autoref{fig:gcs_schematic}), which consists of two straight segments in the legs and a curved segment in the front. The desired resolution, i.e. the number of vertices along each part of the curve, can be passed to the function.
In addition to the the points along the axis, the \texttt{skeleton} function also provides the radius of the circular shell at each point, and the orientation of these circles (i.e. the the tangent vector to the central axis in the $xy$ plane), which are necessary for the following generation of the outer shell.
The \verb|gcs_mesh| function (based on \texttt{cmecloud.pro} in SolarSoft) then uses the output of the \texttt{skeleton} function to construct a 3D mesh by generating circles around each point of the central axis with the appropriate radius and orientation. The parameters of the \verb|gcs_mesh| function are the half angle $\alpha$, the \ac{CME} height $h_\text{apex}$, and the aspect ratio $\kappa$, as well as the desired numbers of vertices along the straight segments, along the front, and along each circle in the mesh.

\begin{figure}
	\centering
	\input{plots/gcs_geometry.pgf}
	\caption[Results of the functions from the \ac{GCS} Python implementation.]{Results of the functions from the \ac{GCS} Python implementation. The left panel shows the central axis of the flux rope, calculated using the \texttt{skeleton} function, in orange, and the surrounding circles generated by the \texttt{gcs\_mesh} function in blue. The right panel shows a 3D wireframe representation of the same data. The input parameters $\alpha$ and $\kappa$ are the same as in \autoref{fig:gcs_schematic}.}
	\label{fig:gcs_geometry}
\end{figure}

In addition to these basic routines to construct the \ac{GCS} mesh, there is also a function \verb|gcs_mesh_rotated|, which uses the 3 angles $\theta, \phi, \gamma$ to rotate the \ac{CME} cloud in 3D space, and the function \verb|gcs_mesh_sunpy|, which converts the rotated \ac{GCS} mesh into a \textit{SunPy} \texttt{SkyCoord} object. This object then contains the necessary metadata about the coordinate system so that the model can directly be integrated into a \textit{SunPy} plot.

\section{Graphical user interface}

In addition to the implementation of the \ac{GCS} geometry, I created a convenient \ac{GUI} that can be used to fit the \ac{GCS} model to coronagraph images. As \textit{SunPy} already provides functions to obtain coronagraph images and to perform the coordinate transformations necessary to overplot arbitrary points in space on these images, the implementation of the \ac{GUI} using \textit{SunPy} was relatively simple.

For starting the \ac{GUI}, a command line interface is provided. For example,
\begin{minted}{bash}
gcs_gui "2013-05-13 16:54" STB SOHO STA
\end{minted}
starts the \ac{GCS} \ac{GUI} with the closest available coronagraph images to the given date and time from \ac{STEREO}-B, \ac{SOHO} and \ac{STEREO}-A. Additional command line options are available to set which coronagraph should be used (\texttt{-soho C2} or \texttt{C3}, and \texttt{-stereo COR1} or \texttt{COR2}) and whether to show running difference images (\texttt{-rd}).

The \ac{GUI} components, e.g. sliders and text boxes for each input parameter, were implemented using the \textit{PyQt5} library \footnote{\url{https://riverbankcomputing.com/software/pyqt/}}, which provides Python bindings for the popular \ac{GUI} framework \textit{Qt}. The \ac{GUI} is defined in the \texttt{gcs.gui} module as the \texttt{GCSGui} class. For embedding the solar images into the Qt window, it uses a plotting canvas provided by the \textit{matplotlib} plotting package (\texttt{FigureCanvasQTAgg}).

When the user starts the \ac{GUI}, it first retrieves the desired coronagraph images through the Internet. This is done using the Helioviewer.org Application Programming Interface (API) \footnote{\url{https://api.helioviewer.org/docs/v2/}}, which directly provides images in JPEG2000 format, to which all necessary calibration and background subtraction were already applied on the server side. This drastically simplifies and speeds up the process compared to the \ac{IDL} version, where images in FITS format need to be downloaded manually from the respective mission sites, and the calibration procedure needs to be applied locally (requiring an installation of SSWDB). The JPEG2000 images provided by Helioviewer also include additional metadata about the observer location and field of view, which are copied from the original FITS file and are necessary to plot the images in the correct coordinate system (solar latitude and longitude).

When the images are downloaded, the \ac{GCS} \ac{GUI} plots them using \textit{SunPy} and displays the result in the plotting canvas (see \autoref{fig:gcs_screenshot}). The \ac{GCS} croissant mesh is then plotted on top of these images and the user can adjust the \ac{GCS} parameters interactively with the six sliders and numerical input boxes on the right side of the window. Three additional controls are provided: A checkbox to show or hide the \ac{GCS} mesh, a text view showing the calculated apex radius of the flux rope ($R_\text{apex}$, cf. \autoref{fig:gcs_schematic}), and a button to save the \ac{GCS} parameters to a file. The latter, stores the data in the \ac{JSON} format, a general-purpose data format that can be easily handled with most modern programming languages. On the top of the \ac{GCS} window, the standard \textit{matplotlib} controls are also shown to allow zooming and panning in the images, as well as saving the current set of images to a file.

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{images/gcs_screenshot.png}
	\caption[Screenshot of the \ac{GCS} Python \ac{GUI}]{Screenshot of the \ac{GCS} Python \ac{GUI}. The left part of the window shows the plotting canvas with running-difference coronagraph images of the April 15, 2020 \ac{CME} \citep[see][]{Forstner-2021-SolO}, and the user controls for the \ac{GCS} parameters are shown on the right.}
	\label{fig:gcs_screenshot}
\end{figure}

During the development of the \ac{GCS} \ac{GUI}, I discovered two problems with the data provided to \textit{SunPy} by the Helioviewer.org API: First, the \ac{STEREO}-B COR2 images were temporarily not available through the API in October 2020, an issue which has since been resolved by the Helioviewer team\footnote{\url{https://github.com/Helioviewer-Project/helioviewer.org/issues/288}}. Second, there was an issue with the metadata included in the \ac{SOHO}/LASCO files: The \ac{SOHO} spacecraft performs a roll maneuver every three months to keep its high gain antenna oriented towards Earth. The files provided by Helioviewer.org already take this into account by rotating the images accordingly, so that the solar north pole is always pointing upwards. However, the metadata in the JPEG2000 files are not adjusted accordingly\footnote{\url{https://github.com/sunpy/sunpy/issues/4553}}, so \textit{SunPy} still interprets these images as though they were rotated by \SI{180}{\degree}. This obviously caused the location of the \ac{GCS} model results in the LASCO images to be incorrect. Thus, I have implemented a workaround into the \ac{GCS} \ac{GUI} to reset the rotation metadata of the LASCO files, and also submitted a patch\footnote{\url{https://github.com/sunpy/sunpy/pull/4561}} to the \textit{SunPy} project to address this issue, which is included in version 2.1 of \textit{SunPy}.

Possible future improvements to the \ac{GCS} \ac{GUI} could include adding an option to calculate base difference images as an alternative to the current options of direct and running difference images. In addition, further tools could be provided to facilitate the fitting of time series, so that the user can simply provide a start and end time and the \ac{GUI} would directly provide one image after another and store the fitting results for each time step in one file. The toolkit may also be easily extended to include support for additional data sources as soon as they are supported by \textit{SunPy}, such as the Wide-Field Imager onboard Parker Solar Probe \citep[WISPR,][]{Vourlidas-2016-WISPR}, the Metis coronagraph onboard Solar Orbiter \citep{Antonucci-2020-Metis} and the Solar Orbiter Heliospheric Imager \citep[SoloHI,]{Howard-2020-SoloHI}.

\section{Validation}

To validate that the Python implementation of \ac{GCS} yields the correct results, I have re-plotted a set of \acp{CME}  with the Python \ac{GCS} \ac{GUI} that were previously fitted using the \ac{IDL} version, and compared the resulting plots. One example of this is shown in \autoref{fig:gcs_validation} for a \ac{CME} launched on May 13, 2013 \citep[originally reconstructed by][Figure 2]{Gou-2020}. The corresponding input parameters are shown in \autoref{tab:gcs_validation_params}.

\begin{figure}
	\centering
	\includegraphics[width=0.9\textwidth]{images/gcs_validation_20130513_idl.png}\\[5mm]
	\includegraphics[width=\textwidth]{images/gcs_validation_20130513_python.pdf}
	\caption[Validation of the \ac{GCS} Python implementation]{Validation of the \ac{GCS} Python implementation. Both panels show the same \ac{CME} on May 13, 2013, with the \ac{GCS} parameters listed in \autoref{tab:gcs_validation_params}. The top image was generated by the \ac{IDL} implementation of \ac{GCS}, while the bottom panel shows the result of the new Python implementation.}
	\label{fig:gcs_validation}
\end{figure}

\begin{table}
	\centering
	\begin{tabular}{rS[table-format=3.2]}
		\toprule
		                                  {Parameter} & {Value} \\ \midrule
		   Stonyhurst Longitude $\phi$ [\si{\degree}] & 270     \\
		Heliographic Latitude $\theta$ [\si{\degree}] & 19      \\
		           Tilt angle $\gamma$ [\si{\degree}] & 35      \\
		           Half angle $\alpha$ [\si{\degree}] & 28      \\
		      Apex height $R_\text{apex}$ [$R_\odot$] & 10.8    \\
		                        Aspect ratio $\kappa$ & 0.35    \\ \bottomrule
	\end{tabular}
	\caption[\ac{GCS} parameters for \autoref{fig:gcs_validation}]{\ac{GCS} parameters for the May 13, 2013 \ac{CME} shown in \autoref{fig:gcs_validation}.}
	\label{tab:gcs_validation_params}
\end{table}

Similar comparisons were performed for other \acp{CME}  with different characteristics: The June 21, 2011 \ac{CME} \citep[originally reconstructed by][Table 1]{Heinemann-2019}, the May 25, 2014 \ac{CME} \citep[originally reconstructed by][Figure 5b]{Dumbovic2018-ForbMod}, as well as the April 15, 2020 \ac{CME} studied by \citet{Forstner-2021-SolO}. In all cases, the \ac{GCS} 3D meshes generated by the Python implementation match the \ac{CME} signatures in the coronagraph images as well as the original results from the \ac{IDL} implementation. This shows that the Python version is implemented correctly and can be used for scientific purposes.
